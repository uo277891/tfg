import { LitVocabTerm } from "@inrupt/lit-vocab-term";
import { NamedNode } from "rdf-js";
/**
  Generated by artifact generator [@inrupt/lit-artifact-generator], version [0.10.15]
  as part of artifact: [vocab-common], version: [0.3.11]
  at 'Saturday, May 30, 2020 1:18 AM'.

  Vocabulary built from vocab list file: [/home/pmcb55/Work/Projects/LIT/lit-vocab/vocab/lit-rdf-vocab/Common/Vocab-List-LIT-Common.yml].

  Extension to UI terms providing multilingual alternative names and translations for comments (e.g. for use directly as labels or tool-tips in user interfaces or error messages)
 */
declare function _NS(localName: string): NamedNode;
declare const UI: {
    PREFIX: string;
    NAMESPACE: string;
    PREFIX_AND_NAMESPACE: {
        ui: string;
    };
    NS: typeof _NS;
    /**
     *
     */
    BooleanField: LitVocabTerm;
    /**
     *
     */
    NumericField: LitVocabTerm;
    /**
     *
     */
    ValueField: LitVocabTerm;
    /**
     *
     */
    Group: LitVocabTerm;
    /**
     * A form can be any type of single field, or typically a Group of several fields,
      including interspersed headings and comments.
     */
    Form: LitVocabTerm;
    /**
     *
     */
    Single: LitVocabTerm;
    /**
     *
     */
    Choice: LitVocabTerm;
    /**
     * A classifier allows the user to select the type of an object.
      The possible types must be subclasses of some overall class, the "category".
      (Ideally, the superclass is also set up as the disjoint union of the subclasses,
      if they are disjoint.)
  
      The form normally stores the resulting classes using an rdf:type triple,
      but a different predicate can be used if required, so the classifier field
      needs is 'property' defined too.
  
      If the subclass selected itself is has subclasses defined, the user can
      recursively select from them in turn, as many levels as needed.
     */
    Classifier: LitVocabTerm;
    /**
     *
     */
    ColorField: LitVocabTerm;
    /**
     *
     */
    Comment: LitVocabTerm;
    /**
     *
     */
    DateField: LitVocabTerm;
    /**
     *
     */
    DateTimeField: LitVocabTerm;
    /**
     *
     */
    DecimalField: LitVocabTerm;
    /**
     *
     */
    EmailField: LitVocabTerm;
    /**
     *
     */
    Heading: LitVocabTerm;
    /**
     *
     */
    SingleLineTextField: LitVocabTerm;
    /**
     *
     */
    TextField: LitVocabTerm;
    /**
     *
     */
    Options: LitVocabTerm;
    /**
     *
     */
    IntegerField: LitVocabTerm;
    /**
     *
     */
    FloatField: LitVocabTerm;
    /**
     *
     */
    PhoneField: LitVocabTerm;
    /**
     *
     */
    Multiple: LitVocabTerm;
    /**
     *
     */
    MultiLineTextField: LitVocabTerm;
    /**
     *
     */
    TriStateField: LitVocabTerm;
    /**
     * parts
     */
    parts: LitVocabTerm;
    /**
     * from
     */
    from: LitVocabTerm;
    /**
     * Label
     */
    label: LitVocabTerm;
    /**
     * Many fields prompt for information about a given property of the subject.
      When field is filled in, this gives which property is written into the data.
     */
    property: LitVocabTerm;
    /**
     * The value for which this case is selected.
     */
    for_: LitVocabTerm;
    /**
     * A string for the UI to use if the user needs a longer
          prompts than just a field name, the rdfs:label.
     */
    prompt: LitVocabTerm;
    /**
     *
     */
    use: LitVocabTerm;
    /**
     * A form which may be used to collect information about a
      hitherto locally undocumented instance instance of this class.
     */
    creationForm: LitVocabTerm;
    /**
     * Contents
     */
    contents: LitVocabTerm;
    /**
     * size of field
     */
    size: LitVocabTerm;
    /**
     * Must be a valid CSS style string such as one could put in
          an HTML style attribute.  Depending on the user interface system, this can
          by given to individuals, classes or properties. It is up to a user interface
          which wants to draw on them to pick how it uses styles from which parts
          of the data it has.  For example, the style of a class may be picked
          to distinguish information about things in that class.
     */
    style: LitVocabTerm;
    /**
     * The superclass subclasses of which will be selected.
     */
    category: LitVocabTerm;
    /**
     * Many fields prompt for information about a given property of the subject
     */
    dependingOn: LitVocabTerm;
    /**
     * max length of value
     */
    maxLength: LitVocabTerm;
    /**
     * part
     */
    part: LitVocabTerm;
    /**
     * A form which may be used to add more infromation to an
  instance of this class which we know something about.  Anything from
  adding just add one more fact, to adding a whole lot of information about a specific
  facet of the thing.
  
     */
    annotationForm: LitVocabTerm;
    /**
     * Must be a valid CSS color string such as one could put in
          an HTML style attribute.  This should be in the #xxxxxx form,
          (with 6 digits of hex)  so that it
          can work with Graphviz.
     */
    backgroundColor: LitVocabTerm;
    /**
     * URI or base64 representation of an image
     */
    backgroundImage: LitVocabTerm;
    /**
     * Must be a valid CSS color string such as one could put in
          an HTML style attribute.  This should be in the #xxxxxx form,
          (with 6 digits of hex)  so that it
          can work with Graphviz.
     */
    color: LitVocabTerm;
    /**
     * A really simple way of enabling user interfaces to
              create new information about a class of things is to make a define of properties
              to be specified when a information about a new item
              ("New item" here means an item which the system
              does not have prvious information about yet,
              not an items which has just been created,
              like new friend as opposed to new baby)
     */
    initialProperties: LitVocabTerm;
    /**
     * max
     */
    maxValue: LitVocabTerm;
    /**
     * min
     */
    minValue: LitVocabTerm;
    /**
     * The sequence in which this item is arranged with repect to other parts.
     */
    seqeunce: LitVocabTerm;
    /**
     * A property which typically is used to sort
          members of a given class.
     */
    sortBy: LitVocabTerm;
    /**
     * When individuals or classes must be sorted, then
          if they are given different values of sortPriority a user agent can
          use this as a hint to how to present information.
     */
    sortPriority: LitVocabTerm;
    /**
     * This  is a crude way of specifying a table-based
              view for objects of this class.
     */
    tableProperties: LitVocabTerm;
    /**
     * Pattern
     */
    pattern: LitVocabTerm;
    /**
     * Value
     */
    value: LitVocabTerm;
    /**
     * Values
     */
    values: LitVocabTerm;
    /**
     * Minimum date offset
     */
    minDateOffset: LitVocabTerm;
    /**
     * Maximum date offset
     */
    maxDateOffset: LitVocabTerm;
    /**
     * Minimum datetime offset
     */
    minDatetimeOffset: LitVocabTerm;
    /**
     * Maximum datetime offset
     */
    maxDatetimeOffset: LitVocabTerm;
    /**
     * Name
     */
    name: LitVocabTerm;
    /**
     * Time field
     */
    TimeField: LitVocabTerm;
};
export { UI };
