import { LitVocabTerm, getLocalStore } from "@inrupt/lit-vocab-term";
import dataFactory from "@rdfjs/data-model";

const { namedNode } = dataFactory;
import { NamedNode } from "rdf-js";

/**
  Generated by artifact generator [@inrupt/lit-artifact-generator], version [0.10.15]
  as part of artifact: [vocab-common], version: [0.3.11]
  at 'Saturday, May 30, 2020 1:18 AM'.

  Vocabulary built from vocab list file: [/home/pmcb55/Work/Projects/LIT/lit-vocab/vocab/lit-rdf-vocab/Common/Vocab-List-LIT-Common.yml].

  Extension to UI terms providing multilingual alternative names and translations for comments (e.g. for use directly as labels or tool-tips in user interfaces or error messages)
 */

function _NS(localName: string): NamedNode { 
  return namedNode(`http://www.w3.org/ns/ui#${localName}`);
}

const UI = {
  PREFIX: "ui",
  NAMESPACE: "http://www.w3.org/ns/ui#",
  PREFIX_AND_NAMESPACE: { "ui": "http://www.w3.org/ns/ui#" },
  NS: _NS,

  // *****************
  // All the Classes.
  // *****************

  /**
   *
   */
  BooleanField: new LitVocabTerm(
    _NS("BooleanField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  NumericField: new LitVocabTerm(
    _NS("NumericField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  ValueField: new LitVocabTerm(
    _NS("ValueField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  Group: new LitVocabTerm(
    _NS("Group"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   * A form can be any type of single field, or typically a Group of several fields,
    including interspersed headings and comments.  
   */
  Form: new LitVocabTerm(
    _NS("Form"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addCommentNoLanguage(`A form can be any type of single field, or typically a Group of several fields,
    including interspersed headings and comments.  `),

  /**
   *
   */
  Single: new LitVocabTerm(
    _NS("Single"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  Choice: new LitVocabTerm(
    _NS("Choice"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   * A classifier allows the user to select the type of an object.
    The possible types must be subclasses of some overall class, the "category".
    (Ideally, the superclass is also set up as the disjoint union of the subclasses,
    if they are disjoint.)

    The form normally stores the resulting classes using an rdf:type triple,
    but a different predicate can be used if required, so the classifier field
    needs is 'property' defined too.

    If the subclass selected itself is has subclasses defined, the user can
    recursively select from them in turn, as many levels as needed.
   */
  Classifier: new LitVocabTerm(
    _NS("Classifier"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`classifier`)
    .addCommentNoLanguage(`A classifier allows the user to select the type of an object.
    The possible types must be subclasses of some overall class, the "category".
    (Ideally, the superclass is also set up as the disjoint union of the subclasses,
    if they are disjoint.)

    The form normally stores the resulting classes using an rdf:type triple,
    but a different predicate can be used if required, so the classifier field
    needs is 'property' defined too.

    If the subclass selected itself is has subclasses defined, the user can
    recursively select from them in turn, as many levels as needed.`),

  /**
   *
   */
  ColorField: new LitVocabTerm(
    _NS("ColorField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  Comment: new LitVocabTerm(
    _NS("Comment"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  DateField: new LitVocabTerm(
    _NS("DateField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  DateTimeField: new LitVocabTerm(
    _NS("DateTimeField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  DecimalField: new LitVocabTerm(
    _NS("DecimalField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  EmailField: new LitVocabTerm(
    _NS("EmailField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  Heading: new LitVocabTerm(
    _NS("Heading"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  SingleLineTextField: new LitVocabTerm(
    _NS("SingleLineTextField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  TextField: new LitVocabTerm(
    _NS("TextField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  Options: new LitVocabTerm(
    _NS("Options"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  IntegerField: new LitVocabTerm(
    _NS("IntegerField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  FloatField: new LitVocabTerm(
    _NS("FloatField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  PhoneField: new LitVocabTerm(
    _NS("PhoneField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  Multiple: new LitVocabTerm(
    _NS("Multiple"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  MultiLineTextField: new LitVocabTerm(
    _NS("MultiLineTextField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   *
   */
  TriStateField: new LitVocabTerm(
    _NS("TriStateField"),
    dataFactory,
    getLocalStore(),
    false
  ),

  // *******************
  // All the Properties.
  // *******************

  /**
   * parts
   */
  parts: new LitVocabTerm(
    _NS("parts"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`parts`, "en"),

  /**
   * from
   */
  from: new LitVocabTerm(
    _NS("from"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`from`),

  /**
   * Label
   */
  label: new LitVocabTerm(
    _NS("label"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Label`, "en")
    .addLabel(`Etiqueta`, "es"),

  /**
   * Many fields prompt for information about a given property of the subject.
    When field is filled in, this gives which property is written into the data.
   */
  property: new LitVocabTerm(
    _NS("property"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`property to be stored`, "en")
    .addCommentNoLanguage(`Many fields prompt for information about a given property of the subject.
    When field is filled in, this gives which property is written into the data.`),

  /**
   * The value for which this case is selected.
   */
  for_: new LitVocabTerm(
    _NS("for"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`for`, "en")
    .addCommentNoLanguage(`The value for which this case is selected.`),

  /**
   * A string for the UI to use if the user needs a longer
        prompts than just a field name, the rdfs:label. 
   */
  prompt: new LitVocabTerm(
    _NS("prompt"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`user prompt`)
    .addCommentNoLanguage(`A string for the UI to use if the user needs a longer
        prompts than just a field name, the rdfs:label. `),

  /**
   *
   */
  use: new LitVocabTerm(
    _NS("use"),
    dataFactory,
    getLocalStore(),
    false
  ),

  /**
   * A form which may be used to collect information about a
    hitherto locally undocumented instance instance of this class.
   */
  creationForm: new LitVocabTerm(
    _NS("creationForm"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`creation form`)
    .addCommentNoLanguage(`A form which may be used to collect information about a
    hitherto locally undocumented instance instance of this class.`),

  /**
   * Contents
   */
  contents: new LitVocabTerm(
    _NS("contents"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Contents`, "en")
    .addLabel(`Contenido`, "es"),

  /**
   * size of field
   */
  size: new LitVocabTerm(
    _NS("size"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`size of field`),

  /**
   * Must be a valid CSS style string such as one could put in
        an HTML style attribute.  Depending on the user interface system, this can
        by given to individuals, classes or properties. It is up to a user interface
        which wants to draw on them to pick how it uses styles from which parts
        of the data it has.  For example, the style of a class may be picked
        to distinguish information about things in that class.
   */
  style: new LitVocabTerm(
    _NS("style"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`style`)
    .addCommentNoLanguage(`Must be a valid CSS style string such as one could put in
        an HTML style attribute.  Depending on the user interface system, this can
        by given to individuals, classes or properties. It is up to a user interface
        which wants to draw on them to pick how it uses styles from which parts
        of the data it has.  For example, the style of a class may be picked
        to distinguish information about things in that class.`),

  /**
   * The superclass subclasses of which will be selected.
   */
  category: new LitVocabTerm(
    _NS("category"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`overall superclass`, "en")
    .addCommentNoLanguage(`The superclass subclasses of which will be selected.`),

  /**
   * Many fields prompt for information about a given property of the subject
   */
  dependingOn: new LitVocabTerm(
    _NS("dependingOn"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`depending on`, "en")
    .addCommentNoLanguage(`Many fields prompt for information about a given property of the subject`),

  /**
   * max length of value
   */
  maxLength: new LitVocabTerm(
    _NS("maxLength"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`max length of value`),

  /**
   * part
   */
  part: new LitVocabTerm(
    _NS("part"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`part`, "en"),

  /**
   * A form which may be used to add more infromation to an
instance of this class which we know something about.  Anything from
adding just add one more fact, to adding a whole lot of information about a specific
facet of the thing.

   */
  annotationForm: new LitVocabTerm(
    _NS("annotationForm"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`annotation form`)
    .addCommentNoLanguage(`A form which may be used to add more infromation to an
instance of this class which we know something about.  Anything from
adding just add one more fact, to adding a whole lot of information about a specific
facet of the thing.
`),

  /**
   * Must be a valid CSS color string such as one could put in
        an HTML style attribute.  This should be in the #xxxxxx form,
        (with 6 digits of hex)  so that it
        can work with Graphviz.
   */
  backgroundColor: new LitVocabTerm(
    _NS("backgroundColor"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`background color`, "en")
    .addCommentNoLanguage(`Must be a valid CSS color string such as one could put in
        an HTML style attribute.  This should be in the #xxxxxx form,
        (with 6 digits of hex)  so that it
        can work with Graphviz.`),

  /**
   * URI or base64 representation of an image
   */
  backgroundImage: new LitVocabTerm(
    _NS("backgroundImage"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`background image`, "en")
    .addCommentNoLanguage(`URI or base64 representation of an image`),

  /**
   * Must be a valid CSS color string such as one could put in
        an HTML style attribute.  This should be in the #xxxxxx form,
        (with 6 digits of hex)  so that it
        can work with Graphviz.
   */
  color: new LitVocabTerm(
    _NS("color"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`color`, "en")
    .addCommentNoLanguage(`Must be a valid CSS color string such as one could put in
        an HTML style attribute.  This should be in the #xxxxxx form,
        (with 6 digits of hex)  so that it
        can work with Graphviz.`),

  /**
   * A really simple way of enabling user interfaces to
            create new information about a class of things is to make a define of properties
            to be specified when a information about a new item
            ("New item" here means an item which the system
            does not have prvious information about yet,
            not an items which has just been created,
            like new friend as opposed to new baby)
   */
  initialProperties: new LitVocabTerm(
    _NS("initialProperties"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`initial properties`)
    .addCommentNoLanguage(`A really simple way of enabling user interfaces to
            create new information about a class of things is to make a define of properties
            to be specified when a information about a new item
            ("New item" here means an item which the system
            does not have prvious information about yet,
            not an items which has just been created,
            like new friend as opposed to new baby)`),

  /**
   * max
   */
  maxValue: new LitVocabTerm(
    _NS("maxValue"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`max`),

  /**
   * min
   */
  minValue: new LitVocabTerm(
    _NS("minValue"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`min`),

  /**
   * The sequence in which this item is arranged with repect to other parts.
   */
  seqeunce: new LitVocabTerm(
    _NS("seqeunce"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`sequence number`)
    .addCommentNoLanguage(`The sequence in which this item is arranged with repect to other parts.`),

  /**
   * A property which typically is used to sort
        members of a given class.
   */
  sortBy: new LitVocabTerm(
    _NS("sortBy"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`sort by`)
    .addCommentNoLanguage(`A property which typically is used to sort
        members of a given class.`),

  /**
   * When individuals or classes must be sorted, then
        if they are given different values of sortPriority a user agent can
        use this as a hint to how to present information.
   */
  sortPriority: new LitVocabTerm(
    _NS("sortPriority"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`sort priority`)
    .addCommentNoLanguage(`When individuals or classes must be sorted, then
        if they are given different values of sortPriority a user agent can
        use this as a hint to how to present information.`),

  /**
   * This  is a crude way of specifying a table-based
            view for objects of this class.
   */
  tableProperties: new LitVocabTerm(
    _NS("tableProperties"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`table properties`)
    .addCommentNoLanguage(`This  is a crude way of specifying a table-based
            view for objects of this class.`),

  /**
   * Pattern
   */
  pattern: new LitVocabTerm(
    _NS("pattern"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Pattern`, "en")
    .addLabel(`Modelo`, "es"),

  /**
   * Value
   */
  value: new LitVocabTerm(
    _NS("value"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Value`, "en")
    .addLabel(`Valor`, "es"),

  /**
   * Values
   */
  values: new LitVocabTerm(
    _NS("values"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Values`, "en")
    .addLabel(`Valores`, "es"),

  /**
   * Minimum date offset
   */
  minDateOffset: new LitVocabTerm(
    _NS("minDateOffset"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Minimum date offset`, "en")
    .addLabel(`Fecha mínima compensada`, "es"),

  /**
   * Maximum date offset
   */
  maxDateOffset: new LitVocabTerm(
    _NS("maxDateOffset"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Maximum date offset`, "en")
    .addLabel(`Fecha máxima de desplazamiento`, "es"),

  /**
   * Minimum datetime offset
   */
  minDatetimeOffset: new LitVocabTerm(
    _NS("minDatetimeOffset"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Minimum datetime offset`, "en")
    .addLabel(`Desplazamiento mínimo de fecha y hora`, "es"),

  /**
   * Maximum datetime offset
   */
  maxDatetimeOffset: new LitVocabTerm(
    _NS("maxDatetimeOffset"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Maximum datetime offset`, "en")
    .addLabel(`Desplazamiento máximo de fecha y hora`, "es"),

  /**
   * Name
   */
  name: new LitVocabTerm(
    _NS("name"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Name`, "en")
    .addLabel(`Nombre`, "es"),

  /**
   * Time field
   */
  TimeField: new LitVocabTerm(
    _NS("TimeField"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Time field`, "en")
    .addLabel(`Campo de tiempo`, "es"),

};

export { UI };
