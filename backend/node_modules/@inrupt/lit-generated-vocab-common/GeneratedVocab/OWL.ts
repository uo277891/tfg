import { LitVocabTerm, getLocalStore } from "@inrupt/lit-vocab-term";
import dataFactory from "@rdfjs/data-model";

const { namedNode } = dataFactory;
import { NamedNode } from "rdf-js";

/**
  Generated by artifact generator [@inrupt/lit-artifact-generator], version [0.10.15]
  as part of artifact: [vocab-common], version: [0.3.11]
  at 'Saturday, May 30, 2020 1:18 AM'.

  Vocabulary built from vocab list file: [/home/pmcb55/Work/Projects/LIT/lit-vocab/vocab/lit-rdf-vocab/Common/Vocab-List-LIT-Common.yml].
 */

function _NS(localName: string): NamedNode { 
  return namedNode(`http://www.w3.org/2002/07/owl#${localName}`);
}

const OWL = {
  PREFIX: "owl",
  NAMESPACE: "http://www.w3.org/2002/07/owl#",
  PREFIX_AND_NAMESPACE: { "owl": "http://www.w3.org/2002/07/owl#" },
  NS: _NS,

  // *****************
  // All the Classes.
  // *****************

  /**
   * The class of ontologies.
   */
  Ontology: new LitVocabTerm(
    _NS("Ontology"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`Ontology`)
    .addCommentNoLanguage(`The class of ontologies.`),

  /**
   * The class of collections of pairwise different individuals.
   */
  AllDifferent: new LitVocabTerm(
    _NS("AllDifferent"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`AllDifferent`)
    .addCommentNoLanguage(`The class of collections of pairwise different individuals.`),

  /**
   * The class of collections of pairwise disjoint classes.
   */
  AllDisjointClasses: new LitVocabTerm(
    _NS("AllDisjointClasses"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`AllDisjointClasses`)
    .addCommentNoLanguage(`The class of collections of pairwise disjoint classes.`),

  /**
   * The class of collections of pairwise disjoint properties.
   */
  AllDisjointProperties: new LitVocabTerm(
    _NS("AllDisjointProperties"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`AllDisjointProperties`)
    .addCommentNoLanguage(`The class of collections of pairwise disjoint properties.`),

  /**
   * The class of annotated annotations for which the RDF serialization consists of an annotated subject, predicate and object.
   */
  Annotation: new LitVocabTerm(
    _NS("Annotation"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`Annotation`)
    .addCommentNoLanguage(`The class of annotated annotations for which the RDF serialization consists of an annotated subject, predicate and object.`),

  /**
   * The class of annotation properties.
   */
  AnnotationProperty: new LitVocabTerm(
    _NS("AnnotationProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`AnnotationProperty`)
    .addCommentNoLanguage(`The class of annotation properties.`),

  /**
   * The class of asymmetric properties.
   */
  AsymmetricProperty: new LitVocabTerm(
    _NS("AsymmetricProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`AsymmetricProperty`)
    .addCommentNoLanguage(`The class of asymmetric properties.`),

  /**
   * The class of object properties.
   */
  ObjectProperty: new LitVocabTerm(
    _NS("ObjectProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`ObjectProperty`)
    .addCommentNoLanguage(`The class of object properties.`),

  /**
   * The class of annotated axioms for which the RDF serialization consists of an annotated subject, predicate and object.
   */
  Axiom: new LitVocabTerm(
    _NS("Axiom"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`Axiom`)
    .addCommentNoLanguage(`The class of annotated axioms for which the RDF serialization consists of an annotated subject, predicate and object.`),

  /**
   * The class of OWL classes.
   */
  Class: new LitVocabTerm(
    _NS("Class"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`Class`)
    .addCommentNoLanguage(`The class of OWL classes.`),

  /**
   * The class of OWL data ranges, which are special kinds of datatypes. Note: The use of the IRI owl:DataRange has been deprecated as of OWL 2. The IRI rdfs:Datatype SHOULD be used instead.
   */
  DataRange: new LitVocabTerm(
    _NS("DataRange"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`DataRange`)
    .addCommentNoLanguage(`The class of OWL data ranges, which are special kinds of datatypes. Note: The use of the IRI owl:DataRange has been deprecated as of OWL 2. The IRI rdfs:Datatype SHOULD be used instead.`),

  /**
   * The class of data properties.
   */
  DatatypeProperty: new LitVocabTerm(
    _NS("DatatypeProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`DatatypeProperty`)
    .addCommentNoLanguage(`The class of data properties.`),

  /**
   * The class of deprecated classes.
   */
  DeprecatedClass: new LitVocabTerm(
    _NS("DeprecatedClass"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`DeprecatedClass`)
    .addCommentNoLanguage(`The class of deprecated classes.`),

  /**
   * The class of deprecated properties.
   */
  DeprecatedProperty: new LitVocabTerm(
    _NS("DeprecatedProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`DeprecatedProperty`)
    .addCommentNoLanguage(`The class of deprecated properties.`),

  /**
   * The class of functional properties.
   */
  FunctionalProperty: new LitVocabTerm(
    _NS("FunctionalProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`FunctionalProperty`)
    .addCommentNoLanguage(`The class of functional properties.`),

  /**
   * The class of inverse-functional properties.
   */
  InverseFunctionalProperty: new LitVocabTerm(
    _NS("InverseFunctionalProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`InverseFunctionalProperty`)
    .addCommentNoLanguage(`The class of inverse-functional properties.`),

  /**
   * The class of irreflexive properties.
   */
  IrreflexiveProperty: new LitVocabTerm(
    _NS("IrreflexiveProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`IrreflexiveProperty`)
    .addCommentNoLanguage(`The class of irreflexive properties.`),

  /**
   * The class of named individuals.
   */
  NamedIndividual: new LitVocabTerm(
    _NS("NamedIndividual"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`NamedIndividual`)
    .addCommentNoLanguage(`The class of named individuals.`),

  /**
   * The class of OWL individuals.
   */
  Thing: new LitVocabTerm(
    _NS("Thing"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`Thing`)
    .addCommentNoLanguage(`The class of OWL individuals.`),

  /**
   * The class of negative property assertions.
   */
  NegativePropertyAssertion: new LitVocabTerm(
    _NS("NegativePropertyAssertion"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`NegativePropertyAssertion`)
    .addCommentNoLanguage(`The class of negative property assertions.`),

  /**
   * This is the empty class.
   */
  Nothing: new LitVocabTerm(
    _NS("Nothing"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`Nothing`)
    .addCommentNoLanguage(`This is the empty class.`),

  /**
   * The class of ontology properties.
   */
  OntologyProperty: new LitVocabTerm(
    _NS("OntologyProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`OntologyProperty`)
    .addCommentNoLanguage(`The class of ontology properties.`),

  /**
   * The class of reflexive properties.
   */
  ReflexiveProperty: new LitVocabTerm(
    _NS("ReflexiveProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`ReflexiveProperty`)
    .addCommentNoLanguage(`The class of reflexive properties.`),

  /**
   * The class of property restrictions.
   */
  Restriction: new LitVocabTerm(
    _NS("Restriction"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`Restriction`)
    .addCommentNoLanguage(`The class of property restrictions.`),

  /**
   * The class of symmetric properties.
   */
  SymmetricProperty: new LitVocabTerm(
    _NS("SymmetricProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`SymmetricProperty`)
    .addCommentNoLanguage(`The class of symmetric properties.`),

  /**
   * The class of transitive properties.
   */
  TransitiveProperty: new LitVocabTerm(
    _NS("TransitiveProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`TransitiveProperty`)
    .addCommentNoLanguage(`The class of transitive properties.`),

  // *******************
  // All the Properties.
  // *******************

  /**
   * The annotation property that provides version information for an ontology or another OWL construct.
   */
  versionInfo: new LitVocabTerm(
    _NS("versionInfo"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`versionInfo`)
    .addCommentNoLanguage(`The annotation property that provides version information for an ontology or another OWL construct.`),

  /**
   * The property that determines the class that a universal property restriction refers to.
   */
  allValuesFrom: new LitVocabTerm(
    _NS("allValuesFrom"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`allValuesFrom`)
    .addCommentNoLanguage(`The property that determines the class that a universal property restriction refers to.`),

  /**
   * The property that determines the predicate of an annotated axiom or annotated annotation.
   */
  annotatedProperty: new LitVocabTerm(
    _NS("annotatedProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`annotatedProperty`)
    .addCommentNoLanguage(`The property that determines the predicate of an annotated axiom or annotated annotation.`),

  /**
   * The property that determines the subject of an annotated axiom or annotated annotation.
   */
  annotatedSource: new LitVocabTerm(
    _NS("annotatedSource"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`annotatedSource`)
    .addCommentNoLanguage(`The property that determines the subject of an annotated axiom or annotated annotation.`),

  /**
   * The property that determines the object of an annotated axiom or annotated annotation.
   */
  annotatedTarget: new LitVocabTerm(
    _NS("annotatedTarget"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`annotatedTarget`)
    .addCommentNoLanguage(`The property that determines the object of an annotated axiom or annotated annotation.`),

  /**
   * The property that determines the predicate of a negative property assertion.
   */
  assertionProperty: new LitVocabTerm(
    _NS("assertionProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`assertionProperty`)
    .addCommentNoLanguage(`The property that determines the predicate of a negative property assertion.`),

  /**
   * The annotation property that indicates that a given ontology is backward compatible with another ontology.
   */
  backwardCompatibleWith: new LitVocabTerm(
    _NS("backwardCompatibleWith"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`backwardCompatibleWith`)
    .addCommentNoLanguage(`The annotation property that indicates that a given ontology is backward compatible with another ontology.`),

  /**
   * The data property that does not relate any individual to any data value.
   */
  bottomDataProperty: new LitVocabTerm(
    _NS("bottomDataProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`bottomDataProperty`)
    .addCommentNoLanguage(`The data property that does not relate any individual to any data value.`),

  /**
   * The object property that does not relate any two individuals.
   */
  bottomObjectProperty: new LitVocabTerm(
    _NS("bottomObjectProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`bottomObjectProperty`)
    .addCommentNoLanguage(`The object property that does not relate any two individuals.`),

  /**
   * The property that determines the cardinality of an exact cardinality restriction.
   */
  cardinality: new LitVocabTerm(
    _NS("cardinality"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`cardinality`)
    .addCommentNoLanguage(`The property that determines the cardinality of an exact cardinality restriction.`),

  /**
   * The property that determines that a given class is the complement of another class.
   */
  complementOf: new LitVocabTerm(
    _NS("complementOf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`complementOf`)
    .addCommentNoLanguage(`The property that determines that a given class is the complement of another class.`),

  /**
   * The property that determines that a given data range is the complement of another data range with respect to the data domain.
   */
  datatypeComplementOf: new LitVocabTerm(
    _NS("datatypeComplementOf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`datatypeComplementOf`)
    .addCommentNoLanguage(`The property that determines that a given data range is the complement of another data range with respect to the data domain.`),

  /**
   * The annotation property that indicates that a given entity has been deprecated.
   */
  deprecated: new LitVocabTerm(
    _NS("deprecated"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`deprecated`)
    .addCommentNoLanguage(`The annotation property that indicates that a given entity has been deprecated.`),

  /**
   * The property that determines that two given individuals are different.
   */
  differentFrom: new LitVocabTerm(
    _NS("differentFrom"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`differentFrom`)
    .addCommentNoLanguage(`The property that determines that two given individuals are different.`),

  /**
   * The property that determines that a given class is equivalent to the disjoint union of a collection of other classes.
   */
  disjointUnionOf: new LitVocabTerm(
    _NS("disjointUnionOf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`disjointUnionOf`)
    .addCommentNoLanguage(`The property that determines that a given class is equivalent to the disjoint union of a collection of other classes.`),

  /**
   * The property that determines that two given classes are disjoint.
   */
  disjointWith: new LitVocabTerm(
    _NS("disjointWith"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`disjointWith`)
    .addCommentNoLanguage(`The property that determines that two given classes are disjoint.`),

  /**
   * The property that determines the collection of pairwise different individuals in a owl:AllDifferent axiom.
   */
  distinctMembers: new LitVocabTerm(
    _NS("distinctMembers"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`distinctMembers`)
    .addCommentNoLanguage(`The property that determines the collection of pairwise different individuals in a owl:AllDifferent axiom.`),

  /**
   * The property that determines that two given classes are equivalent, and that is used to specify datatype definitions.
   */
  equivalentClass: new LitVocabTerm(
    _NS("equivalentClass"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`equivalentClass`)
    .addCommentNoLanguage(`The property that determines that two given classes are equivalent, and that is used to specify datatype definitions.`),

  /**
   * The property that determines that two given properties are equivalent.
   */
  equivalentProperty: new LitVocabTerm(
    _NS("equivalentProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`equivalentProperty`)
    .addCommentNoLanguage(`The property that determines that two given properties are equivalent.`),

  /**
   * The property that determines the collection of properties that jointly build a key.
   */
  hasKey: new LitVocabTerm(
    _NS("hasKey"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`hasKey`)
    .addCommentNoLanguage(`The property that determines the collection of properties that jointly build a key.`),

  /**
   * The property that determines the property that a self restriction refers to.
   */
  hasSelf: new LitVocabTerm(
    _NS("hasSelf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`hasSelf`)
    .addCommentNoLanguage(`The property that determines the property that a self restriction refers to.`),

  /**
   * The property that determines the individual that a has-value restriction refers to.
   */
  hasValue: new LitVocabTerm(
    _NS("hasValue"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`hasValue`)
    .addCommentNoLanguage(`The property that determines the individual that a has-value restriction refers to.`),

  /**
   * The annotation property that indicates that a given ontology is incompatible with another ontology.
   */
  incompatibleWith: new LitVocabTerm(
    _NS("incompatibleWith"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`incompatibleWith`)
    .addCommentNoLanguage(`The annotation property that indicates that a given ontology is incompatible with another ontology.`),

  /**
   * The property that determines the collection of classes or data ranges that build an intersection.
   */
  intersectionOf: new LitVocabTerm(
    _NS("intersectionOf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`intersectionOf`)
    .addCommentNoLanguage(`The property that determines the collection of classes or data ranges that build an intersection.`),

  /**
   * The property that determines that two given properties are inverse.
   */
  inverseOf: new LitVocabTerm(
    _NS("inverseOf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`inverseOf`)
    .addCommentNoLanguage(`The property that determines that two given properties are inverse.`),

  /**
   * The property that determines the cardinality of a maximum cardinality restriction.
   */
  maxCardinality: new LitVocabTerm(
    _NS("maxCardinality"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`maxCardinality`)
    .addCommentNoLanguage(`The property that determines the cardinality of a maximum cardinality restriction.`),

  /**
   * The property that determines the cardinality of a maximum qualified cardinality restriction.
   */
  maxQualifiedCardinality: new LitVocabTerm(
    _NS("maxQualifiedCardinality"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`maxQualifiedCardinality`)
    .addCommentNoLanguage(`The property that determines the cardinality of a maximum qualified cardinality restriction.`),

  /**
   * The property that determines the collection of members in either a owl:AllDifferent, owl:AllDisjointClasses or owl:AllDisjointProperties axiom.
   */
  members: new LitVocabTerm(
    _NS("members"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`members`)
    .addCommentNoLanguage(`The property that determines the collection of members in either a owl:AllDifferent, owl:AllDisjointClasses or owl:AllDisjointProperties axiom.`),

  /**
   * The property that determines the cardinality of a minimum cardinality restriction.
   */
  minCardinality: new LitVocabTerm(
    _NS("minCardinality"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`minCardinality`)
    .addCommentNoLanguage(`The property that determines the cardinality of a minimum cardinality restriction.`),

  /**
   * The property that determines the cardinality of a minimum qualified cardinality restriction.
   */
  minQualifiedCardinality: new LitVocabTerm(
    _NS("minQualifiedCardinality"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`minQualifiedCardinality`)
    .addCommentNoLanguage(`The property that determines the cardinality of a minimum qualified cardinality restriction.`),

  /**
   * The property that determines the class that a qualified object cardinality restriction refers to.
   */
  onClass: new LitVocabTerm(
    _NS("onClass"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`onClass`)
    .addCommentNoLanguage(`The property that determines the class that a qualified object cardinality restriction refers to.`),

  /**
   * The property that determines the data range that a qualified data cardinality restriction refers to.
   */
  onDataRange: new LitVocabTerm(
    _NS("onDataRange"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`onDataRange`)
    .addCommentNoLanguage(`The property that determines the data range that a qualified data cardinality restriction refers to.`),

  /**
   * The property that determines the datatype that a datatype restriction refers to.
   */
  onDatatype: new LitVocabTerm(
    _NS("onDatatype"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`onDatatype`)
    .addCommentNoLanguage(`The property that determines the datatype that a datatype restriction refers to.`),

  /**
   * The property that determines the collection of individuals or data values that build an enumeration.
   */
  oneOf: new LitVocabTerm(
    _NS("oneOf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`oneOf`)
    .addCommentNoLanguage(`The property that determines the collection of individuals or data values that build an enumeration.`),

  /**
   * The property that determines the n-tuple of properties that a property restriction on an n-ary data range refers to.
   */
  onProperties: new LitVocabTerm(
    _NS("onProperties"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`onProperties`)
    .addCommentNoLanguage(`The property that determines the n-tuple of properties that a property restriction on an n-ary data range refers to.`),

  /**
   * The property that determines the property that a property restriction refers to.
   */
  onProperty: new LitVocabTerm(
    _NS("onProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`onProperty`)
    .addCommentNoLanguage(`The property that determines the property that a property restriction refers to.`),

  /**
   * The annotation property that indicates the predecessor ontology of a given ontology.
   */
  priorVersion: new LitVocabTerm(
    _NS("priorVersion"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`priorVersion`)
    .addCommentNoLanguage(`The annotation property that indicates the predecessor ontology of a given ontology.`),

  /**
   * The property that determines the n-tuple of properties that build a sub property chain of a given property.
   */
  propertyChainAxiom: new LitVocabTerm(
    _NS("propertyChainAxiom"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`propertyChainAxiom`)
    .addCommentNoLanguage(`The property that determines the n-tuple of properties that build a sub property chain of a given property.`),

  /**
   * The property that determines that two given properties are disjoint.
   */
  propertyDisjointWith: new LitVocabTerm(
    _NS("propertyDisjointWith"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`propertyDisjointWith`)
    .addCommentNoLanguage(`The property that determines that two given properties are disjoint.`),

  /**
   * The property that determines the cardinality of an exact qualified cardinality restriction.
   */
  qualifiedCardinality: new LitVocabTerm(
    _NS("qualifiedCardinality"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`qualifiedCardinality`)
    .addCommentNoLanguage(`The property that determines the cardinality of an exact qualified cardinality restriction.`),

  /**
   * The property that determines that two given individuals are equal.
   */
  sameAs: new LitVocabTerm(
    _NS("sameAs"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`sameAs`)
    .addCommentNoLanguage(`The property that determines that two given individuals are equal.`),

  /**
   * The property that determines the class that an existential property restriction refers to.
   */
  someValuesFrom: new LitVocabTerm(
    _NS("someValuesFrom"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`someValuesFrom`)
    .addCommentNoLanguage(`The property that determines the class that an existential property restriction refers to.`),

  /**
   * The property that determines the subject of a negative property assertion.
   */
  sourceIndividual: new LitVocabTerm(
    _NS("sourceIndividual"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`sourceIndividual`)
    .addCommentNoLanguage(`The property that determines the subject of a negative property assertion.`),

  /**
   * The property that determines the object of a negative object property assertion.
   */
  targetIndividual: new LitVocabTerm(
    _NS("targetIndividual"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`targetIndividual`)
    .addCommentNoLanguage(`The property that determines the object of a negative object property assertion.`),

  /**
   * The property that determines the value of a negative data property assertion.
   */
  targetValue: new LitVocabTerm(
    _NS("targetValue"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`targetValue`)
    .addCommentNoLanguage(`The property that determines the value of a negative data property assertion.`),

  /**
   * The data property that relates every individual to every data value.
   */
  topDataProperty: new LitVocabTerm(
    _NS("topDataProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`topDataProperty`)
    .addCommentNoLanguage(`The data property that relates every individual to every data value.`),

  /**
   * The object property that relates every two individuals.
   */
  topObjectProperty: new LitVocabTerm(
    _NS("topObjectProperty"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`topObjectProperty`)
    .addCommentNoLanguage(`The object property that relates every two individuals.`),

  /**
   * The property that determines the collection of classes or data ranges that build a union.
   */
  unionOf: new LitVocabTerm(
    _NS("unionOf"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`unionOf`)
    .addCommentNoLanguage(`The property that determines the collection of classes or data ranges that build a union.`),

  /**
   * The property that determines the collection of facet-value pairs that define a datatype restriction.
   */
  withRestrictions: new LitVocabTerm(
    _NS("withRestrictions"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabelNoLanguage(`withRestrictions`)
    .addCommentNoLanguage(`The property that determines the collection of facet-value pairs that define a datatype restriction.`),

};

export { OWL };
